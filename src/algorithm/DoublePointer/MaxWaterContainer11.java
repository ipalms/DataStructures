package algorithm.DoublePointer;

/**
 * 11. 盛最多水的容器
 * 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
 * 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。
 * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
 * 说明：你不能倾斜容器。
 * 示例 1：
 * 输入：[1,8,6,2,5,4,8,3,7]
 * 输出：49
 * 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。
 * 在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
 * 示例 2：
 * 输入：height = [1,1]
 * 输出：1
 * 示例 3：
 * 输入：height = [4,3,2,1,4]
 * 输出：16
 * 示例 4：
 * 输入：height = [1,2,1]
 * 输出：2
 * 提示：
 * n = height.length
 * 2 <= n <= 3 * 104
 * 0 <= height[i] <= 3 * 10^4
 */
public class MaxWaterContainer11 {

    /**
     * 这题双指针和接雨水42题的双指针有些相似，都是通过初始化数组两侧的双指针不断取优或取和
     */

    /**
     * 双指针题解流程（缩减搜索空间思想--能使时间复杂度降低一个维度）：
     * 初始设置双指针i,j分别位于容器壁两端，每次选定围成水槽两板高度h[i],h[j]中的短板向中间收窄1格。
     * 并且更新面积最大值 res，直到 i == j 时返回 res。
     * 为什么双指针是正确的？
     * 在每一个状态下，无论长板或短板收窄1格，都会导致水槽底边宽度-1：不妨先假设h[i]<h[j]
     * 若向内移动短板，水槽的短板min(h[i],h[j])可能变大变小，因此水槽面积S(i,j)可能增大。
     * 若向内移动长板，水槽的短板min(h[i],h[j])不变或变小，下个水槽的面积一定小于当前水槽面积。
     * 为什么移动长板面积一定小于不移动，由于水槽盛水是由短板长度决定的，即不断移动长板水槽的宽度还是由短板决定
     * 加之水槽长度缩小，即可以确保最优解不会出现i为左边界，任意小于j的右边界范围内
     * 更科学说法：
     * 若不指定移动规则，所有移动出现的S(i,j) 的状态数为C(n,2)，即暴力枚举出所有状态。
     * 在状态S(i,j)下向内移动短板至S(i+1,j)（假设h[i]<h[j] ），则相当于消去了
     * S(i,j−1),S(i,j−2),...,S(i,i+1) 状态集合。而所有消去状态的面积一定<=S(i,j)：
     * 短板高度：相比 S(i, j)S(i,j) 相同或更短（<=h[i]）；
     * 底边宽度：相比 S(i, j)S(i,j) 更短。
     * 因此所有消去的状态的面积都<S(i,j)。
     * 通俗的讲，我们每次向内移动短板，所有的消去状态都不会导致丢失面积最大值 。
     */
    public int maxArea(int[] height) {
        int n=height.length;
        int i=0,j=n-1,max=0;
        while(i<j){
            max=Math.max(max,(j-i)*Math.min(height[i],height[j]));
            if(height[i]<=height[j]){
                i++;
            }else{
                j--;
            }
        }
        return max;
    }


    /**
     * 暴力遍历 超时
     * 时间复杂度O（n^2）
     */
    public int maxAreaViolence(int[] height) {
        int n=height.length;
        int max=0;
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                max=Math.max(max,(j-i)*Math.min(height[j],height[i]));
            }
        }
        return max;
    }
}
