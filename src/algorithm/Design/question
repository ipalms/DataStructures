单调队列相关题目：
剑指 Offer 59 - II. 队列的最大值、239. 滑动窗口最大值、1438. 绝对差不超过限制的最长连续子数组
862. 和至少为 K 的最短子数组（前缀和+单调双端队列）
/**
 * 关于== 和 equals的一个坑
 * 由于队列中存储的须是Integer对象，所以不能直接使用两个队列的max.peekFirst()==vals.peekFirst()
 * 来比较两个队头元素是否相等，因为这样比较的是两个Integer对象是否相等（这样如果不是添加的同一个对象进两个队列是不相等的）
 * 所以要使用的话需要是max.peekFirst().equals(vals.peekFirst())来比较两个数据是否相等
 * 因为Integer重写了equals方法，比较的是存储的数据（其他基础数据类型的包装类比较同理）、
 * String也要使用equals比较（默认的Object.equals方法是比较对象的地址 == 号）
 * 基础数据类型的包装类如果不使用equals比较的话，也可以先拆箱一个基础类型
 * 然后再使用这个基础类型与另一个包装类进行比较，这样就会使这个包装类也自动拆箱进行比较
 * 以这剑指Offer59来看就是：
 * int res=vals.pollFirst()  先拆箱一个包装类
 * max.peekFirst()==res      ==号比较时，另一个包装类也会自动拆箱（自动拆箱属于语法糖--编译器层面）
 */