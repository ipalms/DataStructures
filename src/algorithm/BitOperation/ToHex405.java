package algorithm.BitOperation;

import org.junit.Test;

/**
 * 405. 数字转换为十六进制数
 * 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。
 * 注意:
 * 十六进制中所有字母(a-f)都必须是小写。
 * 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；
 * 对于其他情况，十六进制字符串中的第一个字符将不会是0字符。
 * 给定的数确保在32位有符号整数范围内。
 * 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
 * 示例 1：
 * 输入:
 * 26
 * 输出:
 * "1a"
 * 示例 2：
 * 输入:
 * -1
 * 输出:
 * "ffffffff"
 */
public class ToHex405 {

    @Test
    public void test(){
        toHex(-109);
    }

    /**
     * 补码：计算计负数的表示形式
     * 以1byte 8位来演示（最高位表示正负数） -9的补码
     * +9原码：00001001
     * 反码（原码各位取反）：11110110
     * -9补码（反码+1）：11110111
     *
     * 注意这题要使用无符号位移符>>>（符号位也会随着移动）  >>有符号位移符（符号位不动）
     * 位运算+分组换算
     * 将长度为32的二进制转换为16进制数,本质是对长度为32的二进制数进行分组
     * 每4个一组(二进制 1111)2表示15,则使用长度为4的二进制可以表示0-15 )。
     * 同时，由于我们是直接对长度为32的二进制进行分组转算(4个为一组，共8组)
     * 而长度为32的二进制本身就是使用补码规则来表示的，因此我们无须额外处理「补码」问题。
     * 具体的，我们将num与15=(1111)2进行&运算，然后对num进行无符号右移4位来实现每4位处理。
     *
     * 为什么不能使用%这个符号？
     * 对于正数来说可以使用%转化，但是对于负数来说，由于采用的是补码的形式表示负数
     * 但是%取法是按照数学意义去取余，所以转化16时最底位是不正确的
     */
    public String toHex(int num) {
        if(num==0) return "0";
        StringBuilder sb=new StringBuilder();
        while(num!=0){
            sb.append(convert(num&15));
            num>>=4;
        }
        return sb.reverse().toString();
    }

    private char convert(int num){
        if(num<=9) return (char)('0'+num);
        return (char)('a'+num-10);
    }
}
