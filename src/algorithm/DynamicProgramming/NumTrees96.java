package algorithm.DynamicProgramming;

/**
 * 96. 不同的二叉搜索树
 * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？
 * 返回满足题意的二叉搜索树的种数。
 * 示例 1：
 * 输入：n = 3
 * 输出：5
 * 示例 2：
 * 输入：n = 1
 * 输出：1
 * 提示：
 * 1 <= n <= 19
 */
public class NumTrees96 {

    /**
     * 95题是要求列举出节点的取值（回溯||递归生成树）【树区】
     * 本题不能使用回溯做，因为n的最大取值为19，使用回溯会超时
     */

    /**
     * 给定一个有序序列1⋯n，为了构建出一棵二叉搜索树，我们可以遍历每个数字i，
     * 将该数字作为树根，将1⋯(i−1)序列作为左子树，将(i+1)⋯n 序列作为右子树。
     * 接着我们可以按照同样的方式递归构建左子树和右子树。
     * 在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。
     * 原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题
     * 题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：
     * 定义两个函数：
     * G(n): 长度为n的序列能构成的不同二叉搜索树的个数。
     * F(i,n): 以i为根、序列长度为n的不同二叉搜索树个数(1≤i≤n)。
     * G(n)可以从F(i,n)得到，而F(i,n)又会递归地依赖于G(n)
     * 不同的二叉搜索树的总数G(n)，是对遍历所有i(1≤i≤n) 的F(i,n)之和。换言之：
     * G(n)=∑F(i,n)（1<=i<=n）
     * F(i,n)=G(i−1)⋅G(n−i)
     *    -->G(n)=∑G(i−1)⋅G(n−i)（1<=i<=n）
     * 对于边界情况，当序列长度为1（只有根）或为0（空树）时，只有一种情况，即：
     * G(0)=1,G(1)=1
     * https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/
     */
    public int numTrees(int n) {
        int[]G=new int[n+1];
        G[0]=1;
        G[1]=1;
        for(int i=2;i<=n;++i){
            for(int j=1;j<=i;++j){
                G[i]+=G[j-1]*G[i-j];
            }
        }
        return G[n];
    }
}
